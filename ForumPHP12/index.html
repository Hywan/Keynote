<!DOCTYPE html>

<html>
<head>
  <title>Anatomie du test — ForumPHP'12</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <meta http-equiv="content-type" content="text/javascript; charset=utf-8" />
  <meta http-equiv="content-type" content="text/css; charset=utf-8" />

  <link type="text/css" href="Css/UI.css" rel="stylesheet" />

  <style>
    div {
        position: relative;
    }

    div.ie::before,
    div.fh::before,
    div.bo::before,
    div.pu::before {
        position: absolute;
        left: -7.5em;
        font-family: TextItalic;
        color: #777;
        text-align: right;
        width: 5em;
        height: 100%;
        padding: 0 .5em;
        border-radius: 4px;
    }

    div.ie::before {
        content: "Ivan";
        background: rgba(199, 226, 243, .4);
    }

    div.fh::before {
        content: "Frédéric";
        background: rgba(216, 234, 210, .4);
    }

    div.bo::before {
        content: "Les deux";
    }

    div.pu::before {
        content: "Public";
    }

    div.pu,
    em.indication {
        color: #777;
    }
  </style>
</head>

<body>

<h1>Histoire</h1>

<h2>Introduction</h2>

<div class="fh"><p>Aujourd'hui, le test devient à la mode dans le monde
industriel. Les outils permettant de les mettre en œuvre sont de plus en plus
nombreux et de plus en plus évolués, les techniques de travail changent tout
comme les mentalités, bref le test se <strong>démocratise</strong> gentiment.
Cependant, l'information à leur sujet est souvent fragmentée et parcellaire, si
bien que la plupart des développeurs et futur-testeurs ont des difficultés à les
appréhender correctement de manière globale et se posent beaucoup de
questions.</p>
<p>L'histoire que nous allons vous raconter a pour but d'apporter quelques
réponses aux questions qui nous ont été le plus souvent posées.</p></div>
<div class="ie">Il était une fois une équipe de développeurs qui souhaitait
concevoir un programme répondant à un besoin avec la meilleure
<strong>qualité</strong> et <strong>assurance</strong> possible, et afin d'y
arriver, ils décidèrent d'utiliser les <strong>tests</strong>.</p>

<h2>Définition</h2>

<p>L'objectif est d'exécuter un SUT pour système sous test sous certaines
conditions et contraintes, pour à la fin vérifier la sortie ou l'état de ce SUT.
Dans le test dit <em>manuel</em>, c'est le testeur qui va écrire toutes les
conditions d'exécution du SUT, ainsi que les <strong>oracles</strong> permettant
de calculer les <strong>verdicts</strong> des tests, tout simplement si les
tests ont été un succès ou ont échoué. Les tests suivent tous ce proccessus à
quelques nuances près.</p></div>
<div class="fh"><p>Cependant, même si c'est le testeur qui va écrire les tests,
il serait nettement plus confortable pour lui de les faire exécuter par une
machine, ce qui lui offrirait beaucoup d'avantages :</p>
<ol>
  <li>la machine est capable d'exécuter les tests aussi souvent que
  nécessaire et cela de manière <strong>automatisé</strong> ;</li>
  <li>la machine offre un gain de temps et d'efficacité ;</li>
</ol>
<p>À ce stade, on parle de <strong>vérification</strong> de programme.</p></div>

<h2>Test unitaire</h2>

<div class="ie"><p>Et avant de tester le programme dans sa totalité, il est plus
évident de tester des petites parties, les unes après les autres. Nous allons
donc chercher quelles sont les parties « <strong>atomiques</strong> » de notre
programme. Le plus souvent, ce seront les fonctions ou les méthodes de classes.
Ces parties sont les fondations de notre programme, il est nécessaire d'avoir
<strong>confiance</strong> dans ces fondations avant de bâtir par dessus.</p>
<p>Nous parlons alors de tests <strong>unitaires</strong>, puisqu'ils ont pour
but de vérifier le fonctionnement de la plus petite unité de code existante, qui
est alors le SUT évoqué précédemment.</p></div>
<div class="fh"><p>Notre équipe de développeurs a donc commencé à écrire du
code, puis ensuite à rédiger les tests correspondants afin de les exécuter
régulièrement. Cela leur a été d'autant plus facile qu'un test unitaire s'écrit
souvent dans le même langage que celui utilisé pour écrire le code. Et pour se
faciliter encore plus la tâche, ils ont utilisé un <strong>framework</strong> de
tests unitaires, car c'est un outil dont le but est d'organiser, faciliter et
simplifier l'écriture et l'exécution de un ou plusieurs tests (dans ce cas, on
parle de <strong>suite</strong> de tests). Un tel framework doit également être
capable de produire des rapports dans différents formats qui permettront aux
développeurs de pouvoir localiser avec précision les tests qui ont échoué et la
raison de cet échec. Ces rapports peuvent également contenir d'autres
informations, notamment sur des <strong>métriques</strong> permettant de
qualifier la qualité des tests. Tout ces facteurs nous permettent de savoir
quelle confiance avoir dans notre code.</p>
<p>Le choix d'un framework de test unitaires a été relativement simple pour
notre équipe de développeur car ils ont tout simplement expérimentés ceux qui
leur semblaient intéressants. Leur choix a été totalement subjectif, mais ce
n'est un mal car l'important n'est pas tant l'outil choisi que le fait d'être
efficace avec. Toutefois, le choix n'est pas anodin car ces outils sont en
général très <strong>peu compatible</strong> entre eux, et par conséquence, il
n'y a pas de solution simple et rapide permettant d'en changer.</p></div>
<div class="ie"><p>Notre équipe écrit donc des tests <em>a posteriori</em> de la
rédaction de leur code avec leur framework de tests unitaires favori. Cependant,
ils n'ont pas tardé à réaliser que cette façon de faire présentait des
inconvénients significatifs.</p>

<h2>Testabilité</h2>

<p>Tout d'abord, ils se sont aperçus que pour être <strong>testable</strong>,
leur code devait forcément suivre un certain nombre de bonnes pratiques de
développement, et le fait d'écrire leurs tests <em>a posteriori</em> rendait
cette contrainte difficile à satisfaire. Ils étaient alors obligé de modifier le
code concerné et de faire plusieurs fois le même travail. De plus, ils se sont
aperçus qu'ils développaient des fonctionnalités dont ils n'avaient pas besoin,
ce qui leur faisait encore perdre plus de temps. Enfin, lors de la mise en œuvre
de leur au sein des tests, ils se rendaient parfois compte qu'il n'était pas
pratique à utiliser, du fait d'une API mal pensée ou peu adaptée au contexte
d'utilisation.</p>
<p>Ces trois problèmes étant induits par le fait d'écrire les tests unitaires
après avoir écrit le code, nos développeurs ont décidé de faire à l'avenir
l'inverse : écrire les tests unitaires <em>a priori</em>.</p></div>

<h2><em>Test Driven Development</em></h2>

<div class="fh"><p>Ce faisant, ils ont donc commencé à appliquer une méthode de
développement connue sous l'acronyme TDD pour <em>Test Driven Development</em>.
Cette méthode impose un développement itératif qui a comme avantage de faciliter
la conception du code. Lorsque l'un de nos développeurs veut écrire du code, il
commence par écrire le test le plus simple posible permettant de le décrire, et
en général il consiste à instancier une classe et à appeler une méthode devant
être testée. Le développeur exécute alors ce test unitaire, qui aboutit
forcément sur un échec puisque le code correspondant n'existe pas encore. La
plupart des frameworks de tests matérialise l'échec sous la forme d'un message
écrit en rouge, d'où l'expression « la barre est rouge ». C'est le signal qui
autorise le développeur a écrire du code mais juste ce qui est nécessaire pour
exécuter que le test devienne un succès et que la « barre devienne verte ».
Comme la méthode de travail est itérative, nous recommençons ce processus en
écrivant un nouveau test et ainsi de suite.</p>

<h2>Régression</h2>

<p>Parfois, la modification du code peut invalider un test déjà existant. Nous
parlons de <strong>régression</strong>. Mais grâce aux tests justement, ces
régressions sont détectées immédiatement et peuvent être corriger rapidement
grâce aux rapports générés par notre outil de test.</p></div>
<div class="ie"><p>Mais parfois, des régressions ont été introduites sans que
les tests ne puissent les détecter immédiatement. Ils se sont demandés comment
être sûr qu'un test soit de bonne <strong>qualité</strong> ? Dans un premier
tant, les tests doivent représenter les <strong>exigences</strong> de notre code
ou de notre projet. Mais nous voulons que les tests apportent un élément de
<strong>sûreté</strong> (notamment avec la détection de régression). Pour cela,
nos développeurs ont écrit des tests <strong>positifs</strong> qui symbolisent
un succès, mais aussi des tests <strong>négatifs</strong> qui symbolisent un
échec. Ils voulaient être sûr que le code faisait ce qu'il devait faire et ne
faisait pas ce qu'il ne devait pas faire.</p>

<h2>Couverture</h2>

<p>Les résultats étaient nettement meilleurs et leur code était devenu de bien
meilleur qualité. Mais ce n'était pas suffisant car dans certains cas, ils
découvraient encore des erreurs inatendues et difficiles à détecter. Ils ont
voulu qualifier la qualité des tests, savoir à quel point ils pouvaient faire
confiance dans leurs tests. Heureusement, une métrique très utile dans le cas
des tests unitaires est la <strong>couverture</strong> du code. Durant
l'exécution d'un test, le framework utilisé va analyser quelle partie du code a
été <strong>atteinte</strong> ou couverte. Une fois la suite de tests exécutée
en entier, l'outil aggrège toutes ces données et nous fournit un rapport
détaillé sur la couverture. Plus elle est importante et plus cela nous indique
que nos tests sont de qualité.</p>
<p>Il existe plusieurs niveaux de couverture. En réalité, nous pouvons
représenter un code par son CFG pour <em>Control Flow Graph</em>. Chaque nœud
dans ce graphe représente un bloc de code et chaque arc (dirigé) représente un
saut d'un nœud vers un autre. Une exécution d'un test sera représenté par un
chemin dans ce graphe. Des couvertures évidentes apparaissent comme par exemple
<em>tous-les-arcs</em>. D'autres sont plus difficiles comme par exemple
<em>tous-les-chemins</em>. En effet, si notre code comporte une boucle,
peut-être qu'une partie sera <strong>atteignable</strong> uniquement après
<em>i</em> passages dans cette boucle ; c'est la couverture
<em>tous-les-<em>i</em>-chemins</em>. Nous pouvons aussi prendre en compte la
dépendance entre les variables, leurs utilisations etc.</p>
<p>Plus la couverture est forte et plus le test sera de qualité. L'objectif
ultime étant la couverture <em>tous-les-chemins</em>.</p>
<p>Malheureusement, selon les langages, rares sont les frameworks capables de
détecter toutes les couvertures. La couverture la plus utilisée est
<em>tous-les-nœuds</em>, elle reste faible mais c'est toujours une
avancée !</p></div>

<h2><em>ping-pong</em></h2>

<div class="fh"><p>Mais nos développeurs ont trouvé une solution supplémentaire
pour améliorer la qualité de leur code directement à la source : travailler en
<strong>binôme</strong>. Ils se partagent ainsi le même écran, le même clavier
et la même souris.</p>
<p>En dehors de l'équipe, certain ont pensé que c'était du gaspillage de
ressources et qu'il fallait en conséquence arrêter immédiatement. Cependant, il
a suffit de regarder attentivement ce binôme en train de travailler pour que les
plus septiques reconnaissent que la paire travaille bien simultanément et en
équipe. En effet, lorsque l'un a le clavier, l'autre porte un regard critique
sur le code qu'il écrit, ce qui lui permet de réparer les erreurs de syntaxe, le
non respect des conventions de codage et de faire des suggestions souvent
bienvenues pour améliorer la lisibilité, la maintenance ou l'efficacité du code
ou des tests. De plus, deux cerveaux sont bien plus à même de répertorier
l'ensemble des cas d'utilisation possibles pour du code, et d'ailleurs, pour y
parvenir au mieux, nos développeurs pratiquent de temps à autre le
<strong>ping-pong</strong>. L'un des deux rédige alors le test tandis que
l'autre écrit le code permettant de l'exécuter avec succès. Les rôles étant
régulièrement permutés afin d'éviter la lassitude et détecter plus
d'erreurs.</p>
<p>Les résultats sont très impressionnants mais cette façon de travailler est
éprouvante car elle ne laisse aucun répit aux deux développeurs, et elle ne doit
donc être utilisée qu'à bon escient. Un dernier avantage du binômage : chaque
membre est amené à travailler sur l'ensemble du code, car les binômes sont très
souvent modifiés et le partage des connaissances se fait donc au fil de l'eau de
manière transparent. Les membres de l'équipe ont tous une vision globale du code
du programme.</p></div>

<h2><em>Mock</em></h2>

<div class="ie"><p>Une vision globale mais pas totale. Dans certains cas, nos
amis devaient travailler sur du code qui nécessitait des parties encore non
développées ou finalisées. Par exemple, il arrive fréquemment qu'un test ait
besoin d'accéder à un système de fichiers, à une base de données ou bien encore
à une connexion réseau, un Web service etc. Or, si ce composant n'existe pas,
cela est bloquant pour la tâche, et même s'il existe, il n'est pas évident de
simuler un disfonctionnement pour avoir une suite de test complète.</p></div>
<div class="fh"><p>C'est pourquoi nos développeurs ont décidé d'utiliser les
<strong>mocks</strong>. Un mock est capable de simuler une dépendance. Son
comportement est spécifié par le testeur. Grâce aux mocks, il devient possible
de simuler des erreurs lors de la sauvegarde d'un fichier ou la parte d'une
connexion à une base de données ou à un réseau, tout en améliorant la
portabilité des tests. Un mock fait parti intégrante du test et il sera en
conséquence toujours disponible indépendamment de son environnement d'exécution.
Nous remarquons aussi que les mocks améliorent la vitesse d'exécution des tests
car, étant virtuels, ils ne dépendent d'aucune contrainte technique et
s'exécutent beaucoup plus rapidement que leurs équivalents du monde réel.
Lorsqu'un mock simule une connexion à un réseau, la latence du réseau ou des
serveurs n'a donc plus aucune influence sur la vitesse d'exécution des tests
(sauf si le mock le spécifie bien entendu).</p></div>
<div class="ie"><p>La mise en œuvre des tests unitaires et plus particulièrement
du TDD ont permis à notre équipe non seulement de gagner en qualité, ce qui
était l'objectif de départ, mais aussi en productivité et en confiance. D'autres
effets positifs n'avaient même pas été anticités. Par exemple, au début du
projet, ils avaient alloué du temps pour la rédaction des test <em>a
posteriori</em>, temps qui s'était révélé bien souvent insuffisant. Or, avec le
TDD, l'écriture des tests revient à développer le code du programme, ce qui
revient à dire que le coût d'écriture des tests est confondu avec le coût du
développement. Il est donc devenu totalement inutile d'allouer du temps
spécifique à l'écriture des tests, ce qui facilite la planification du projet et
a permis d'améliorer la maîtrise des délais. Mais également, à chaque instant du
projet, notre équipe était certaine que l'existant fonctionnait.</p></div>

<h2>Test d'intégration</h2>

<div class="fh"><p>Toutefois, même si les parties unitaires étaient de qualité,
des erreurs pouvaient apparaître au moment d'assembler ces parties. Pour
reprendre notre métaphore sur la maison, les briques étaient toutes bien
réalisées mais personne n'a pensé à regarder si elles sont
<strong>compatibles</strong> entre elles.</p>
<p>Pour cela, une autre technique <strong>complémentaire</strong> au test
unitaire est le test d'<strong>intégration</strong>. Le test d'intégration n'est
pas très différent d'un test unitaire car le SUT est un agrégat d'unités de
code.</p></div>

<h2>Test structurel</h2>

<div class="ie"><p>En fait, nous manipulons toujours du code. Et quand nous
testons à partir du code, nous appelons ça le test <strong>structurel</strong>
(qui comprend la notion de couverture, de CFG etc.). Des outils adaptés au test
unitaire seront probablement adaptés au test d'intégration.</p></div>
<div class="fh"><p>Mais attention, les métriques pour qualifer la qualité d'un
test d'intégration ne sera pas les mêmes. Au lieu d'utiliser la couverture, nous
utiliserons plutôt les exigences du projet mais aussi d'utiliser toutes les
dépendances.</p>
<p>En effet, un test d'intégration se déroule dans un environnement très proche
de celui du monde réel une fois que toutes les dépendances ont été mises en
place, <em>a contrario</em> des tests unitaires qui se basent sur des mocks. Des
surprises peuvent apparaître. La complémentarité entre les techniques de tests
est importante.</p></div>

<h2>Test fonctionnel</h2>

<div class="ie"><p>Armés de leurs tests unitaires et d'intégrations, notre
équipe est donc maintenant certaine de disposer de briques élémentaires fiables
et compatibles, nécessaires à la construction de leur programme. Cependant, ces
tests ne leur permettent pas de vérifier que le programme construit à partir de
ces briques de base répondra aux besoins de ses utilisateurs. Pour reprendre
encore une fois notre métaphore, la maison est construite mais est-ce que la
porte en haut du mur est pratique à utiliser ? Or, c'est justement le rôle des
tests <strong>fonctionnels</strong> de vérifier que le code du programme répond
aux besoin de l'utilisateur.</p>
<p><em>A l'instar</em> du test unitaire ou d'intégration, le test fonctionnel
doit valider le comportement du programme mais encore une fois à un niveau
supérieur. Cependant, il est très différent dans sa forme car il doit permettre
de valider un comportement fonctionnel et non technique. En conséquence, il est
totalement indépendant à tout point de vue du langage utilisé pour le
développement du programme. Il se présente le plus souvent comme un
<strong>script</strong> essayant d'exprimer des séquences de manière simple et
permettant d'amener le système dans un état particulier pour ensuite valider cet
état. L'objectif est de simuler un comportement type d'un utilisateur.</p></div>

<h2>Intégration continue</h2>

<div class="fh"><p>Évidemment, pour que celui soit efficace, il faut la dernière
verison disponible du programme, compilée, assemblée et utilisable par l'outil
de test fonctionnel. Or, réunir tous ces paramètres à tout instant est une tâche
longue et fastidieuse ! C'est la raison pour laquelle notre équipe a mis en
place une plateforme d'<strong>intégration continue</strong> qui récupère les
versions successives du code à tester, exécute les tests, compile et assemble le
programme si tous les indicateurs sont au vert. Le cas échéant, des
notifications sont émises rapidement afin d'avoir un retour
<strong>immédiat</strong>. Ainsi, nos programmeurs gagnent vraiment en
productivité et peuvent corriger leurs erreurs au plus tôt.</p>
<p>Cependant, les tests fonctionnels ont posé un problème à nos développeurs
car, de par leur nature, ils ont eu tout d'abord tendance à y décrire
techniquement plutôt que fonctionnellement la façon dont le programme devrait
fonctionner. Leurs premiers tests fonctionnels étaient étroitement lié au
fonctionnement de leur code, et leur maintenance est vite devenue fastidieus car
chaque modification du code devait obligatoirement être répercutée sur les tests
concernées. Il leur a cependant suffit de ce dire que les tests fonctionnels
devaient continuer à passer même après une refonte complète du code pour
résoudre ce problème. Les tests fonctionnels leur ont également permis de tester
plusieurs interfaces utilisateur pour leur programme. En effet, un programme
doit se comporter de la même façon indépendament de la façon dont l'utilisateur
l'utilise : en ligne de commande, <em>via</em> une interface graphique ou encore
un navigateur Web.</p></div>

<h2>Conclusion</h2>

<div class="ie"><p>Notre équipe de développement est donc aujourd'hui heureuse
et à donner naissance à beaucoup de programmes depuis ses premiers pas dans
l'univers du test. Grâce à la mise en œuvre du TDD et des tests unitaires,
d'intégration et fonctionnels, elle est aujourd'hui parfaitement à même de
livrer du code fiable et répondant aux besoins de ses utilisateurs en toute
confiance. Grâce au binômage, chacun d'eux a une vision plus globale du code et
aucun membre de l'équipe n'est l'expert exclusif d'une partie du code.
L'intégration continue leur permet de surveiller automatiquement que les
modifications ou les évolutions effectués sur leur code n'a pas d'influence
négative.</p>
<p>Pour cela, il leur a fallu mettre en œuvre trois types de tests différents,
chacun d'entre eux étant dédié à un objectif clair et étant complémentaire des
autres.</p></div>
<div class="fh"><p>Notre histoire aurait pu être très différente car il n'y a
pas qu'une seule façon de mettre en œuvre correctement des tests. Il existe
d'autres méthodes que le TDD, tout aussi pertinente, et différentes façons de
rédiger des tests, indépendamment de leur nature. De plus, notre histoire se
déroule au pays des « bisounours », où tout problème a une solution rapide et
efficace avec un coût temporel ou financier nul, ce qui est très éloigné de la
réalité. Dans le « vrai monde », il est en effet parfois nécessaire de devoir
s'adapter pour faire face à des contraintes temporelles ou financières qui ne
nous permettent pas de mettre en œuvre la totalité des tests que l'on
souhaiterait utiliser. Dans ce contexte, le plus important est de garder à
l'esprit que même faire un unique test, à la condition qu'il soit bien écrit
évidemment, est bien plus pertinent que de ne pas faire de test du tout. Enfin,
en fonction du langage de programmation utilisé et des outils employés, les
problèmes rencontrés et leur solution peuvent être très différents.</p>
<p>Tout ce qui précède n'est donc pas une recette magique permettant d'écrire
des tests pertinents et de bonne qualité car il faut de toute façon du temps et
de l'expérience pour y parvenir.</p></div>

</body>
</html>
